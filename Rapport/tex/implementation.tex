\chapter{Design \& Implementation}
\section{The use of frameworks}
Using frameworks because of the decreased development time due to already developed and tested libraries for various tasks such as database accesss, file handling and file uploading.

\section{Backend}
\subsection{The C++ application}
\subsubsection{Why a C++ application?}
We're using a C++ application because it is much faster to parse huge files in C++ than PHP or JavaScript.
The choice of language was because we had some knowledge of both C and C++. C++ is object oriented where as C is a procedural language, and seeing as we all favour object oriented programming, the choice between the two was easy.

We could have chosen other languages such as F, F\#, Java, Perl or Ruby, but our limited knowledge about these made us stick with C++, which is also quite fast and portable.

\subsubsection{Why Qt?}
We've decided to use Qt because of the support and community around it. It's very mature and most importantly, object oriented.

Qt is a cross-platform application framework developed by Nokia. Popular software such as Skype, VLC media player and VirtualBox along with companies such as Google, HP, Philips and Samsung use it.

Qt makes developing an application with a GUI\footnote{Graphical User Interface} relatively easy, but we've opted to only use the command line part of Qt, because the programming is run by the application and not by a user.

\subsubsection{Return codes}
The PHP part of the application gets a return code from the C++ application depending on how the parsing went and reacts accordingly. A list of the return codes can be seen in table \ref{tab:cppReturnCodes}.
\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Code} & \textbf{Explanation}\\
\hline
0 & Failure\\
\hline
1 & Success\\
\hline
2 & Success, unkown params ignored\\
\hline
10 & Failed, missing fileid\\
\hline
11 & Failed, missing filename\\
\hline
12 & Failed, missing type\\
\hline
20 & Unknown file type\\
\hline
21 & File not found\\
\hline
22 & Invalid file, or wrongly formatted\\
\hline
30 & Could not read input file\\
\hline
31 & Could not write to input file\\
\hline
32 & Could not read output file\\
\hline
33 & Could not write to output file\\
\hline
34 & Could not delete output file\\
\hline
\end{tabular}
\caption{Return codes from the C++ application}
\label{tab:cppReturnCodes}
\end{table}

\input{tex/php}

\subsection{Extensibility}
\todo[inline,color=red]{Write the sections together}
\todo[inline]{C++}
The application is coded with extensibility in mind, and all parsers is therefore extending the base class \emph{Parser}.
The \emph{Parser} class contains the basic methods of setting the filename, opening for read and write and closing the open file handle.\todo[color=red,fancyline]{Explain more in-depth?}

\todo[inline]{PHP}
The application, especially the models, has been developed with flexibility and extensibility in mind. Thus, backend support for new file types can be done with very little code. A file type table has to be created with proper columns for data. A \textsf{model} represent the respective row in the table as an object. Both things can be created automatically in the command line with Oil. Listing \ref{lst:oil_command} is an example of how oil commands was used to create the model and migration for the csv file type.
\begin{lstlisting}[language=sh,caption={Oil command for creating model and migration},label={lst:oil_command}]
php oil g model file_csv TimeStamps:char[12] PossiblePower:varchar[10] WindSpeed:varchar[10] RegimePossible:varchar[10] OutputPower:varchar[10] RegimeOutput:varchar[10] TimeStampsR:char[19] file_id:bigint
\end{lstlisting}

The created table will have to be related with the \textsf{files} table on sql level\footnote{See \ref{lst:sql} for relations}.

\section{Frontend}
\subsection{jQuery}
\todo[inline]{Quick roundup about the use of jQuery. Minor rewrite}
JavaScript\footnote{Client-side scripting language for web pages} has been used to load and visualize data. It gives a more smooth design, since the pages don't have to reload every time, but can be loaded in the background.

\todo[fancyline,color=green]{Adam @ sentence: ?}The JavaScript framework there has been used is called jQuery\footnote{JavaScript framework, see \cite{jquery} for the documentation}, because of the very well documentation. jQuery is one of the most popular JavaScript library and is free open source software, so there is a lot of help to get on the web.\\
The animations for radar visualization and chart are made by using jQuery.
 
One of the techniques with jQuery is for instance AJAX\footnote{Asynchronous JavaScript and XML}, which enables the chart to send data to, and retrieve data from, the server asynchronously. Data is retrieved using XMLHttpRequest, since the data is ready in JSON\footnote{JavaScript Object Notation - representing simple data structures and associative arrays - see \cite{json}}.

If the browser doesn't support JavaScript or it isn't up-to-date, the user still has access to upload files, but not viewing data from map or chart.

\subsection{Bootstrap}
\todo[inline]{Quick roundup about the use of Boostrap and its support for smartphones and tablets. Rewrite}
Today many people keep themselves updated on the fly and to give them the opportunity, we have tried to create a design that also works on smartphones, that have smaller screens and lesser processing power. Most of the calculating is done on the server, so the requirements for client-side is almost nothing, other than showing the data that the server has performed.

Bootstrap is used to make sure that the design is working on different devices, for example if the screen is too small, like we know from smartphones, the menu will collapse (see figure \ref{fig:bootstrap}). The user can roll down the menu to get the same menu options as usual.

\begin{figure}[htbp]
\centering
   \includegraphics[scale=.5]{figure/bootstrap.eps}
   \caption{Menu collapse with bootstrap}
   \label{fig:bootstrap}
\end{figure}

The only problem with smartphone is the smaller screen, sometimes it can be difficult to get a good look, specially the charts are a problem.

We have tried accessing the software with iPhone and Android. The only problem was the chart, you couldn't see the whole chart, because of the small screen. Radar and map were working just fine, like on a normal PC.

\subsection{Radar annotation}
In the final stages of the application, it was discussed if the radars should have its name and/or time stamp for the current radar image shown to make it clearer for the user when the image was taken.

Figure \ref{fig:mock_up_inactive_radar} and \ref{fig:mock_up_active_radar} shows the mock ups for the radar in both inactive and active state.
\begin{figure}[htbp]
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figure/radar1.eps}
    \caption{Mock up of inactive radar}
    \label{fig:mock_up_inactive_radar}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{0.5\linewidth}
    \centering
    \includegraphics[width=\linewidth]{figure/radar2.eps}
    \caption{Mock up of active radar}
    \label{fig:mock_up_active_radar}
  \end{minipage}
\end{figure}
The added name and time stamp might pose as a problem, if two radars were placed in such a way that their range would overlap where the name or time stamp were put.

This could be somewhat solved, by fading out the radars too close to an active radar, in the same way that windmills inside the range of a radar is faded out when a radar animation starts.

\section{Speed optimizations}
\todo[inline,color=red]{rader images saved and cached in browser. minify and combine js css. reduce size and requests. fuelphps cache}
At the beginning the chart had monthly, weekly and daily view, but when loading all data for one month, the performance was so poor. This was fixed by changing views to 2-weekly, weekly and daily view.

\subsection{Caching}
Caching has been implemented both on server and client side, to allow for maximum performance when viewing charts and radar image animations.

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Area} & \textbf{Before} & \textbf{Server side} & \textbf{Server + client side}\\
\hline
Radar & \textasciitilde 130-150 ms & \textasciitilde 35 ms & \textasciitilde 2 ms\\
\hline
Chart & \textasciitilde 300 ms & \textasciitilde 40 ms & \textasciitilde 2 ms\\
\hline
\end{tabular}
\label{tab:cache_benchmarks}
\caption{Cache benchmarks}
\end{table}

When a radar image or chart data is requested, the server checks if a cache of the output exists. If it does, it checks if the browser already has a copy of the same cache file and send a \textsf{301 Not Modified} response to the browser, telling it to its own file.
If the browser does not have a cache, or it is too old, the server sends the contents of the new cache to the browser.
If no cache is found on the server, or it has expired, the server retrieves the needed information from the database, generate the image or data to output, saves it to the cache and sends it to the browser.

\section{Cross-platform compability}
\label{sec:cross-platform}
\todo[inline, color=red]{As stated in bootstrap, smartphones and laptops is somewhat supported because of bootstrap. Rewrite}
The use of PHP, C++ and MySQL allows the execution of the application on almost all platforms, because the technologies used are open source and available on most platforms.

We have, however, chosen to drop support for all version of Internet Explorer, because this would increase development time drastically -- time we did not have.

\section{The data}
\subsection{File type support}
The application supports the upload of the following file types:
\begin{description}
\item[csv] Observations form a wind farm. The definition can be found in appendix \ref{ap:csv}.
\item[wrk] Weather image from a radar. The file must obey the new VRIS format. See \cite{VRIS} for the definition of VRIS.
\item[zip] All supported file formats can be zipped to easily upload multiple files at the same time. Unlimited zip and folder nesting is supported\footnote{Note that there might be a limit on the file- or foldername length set by the operating system.}.
\end{description}
\todo[inline,color=red]{NOTE: NC not supported. Rewrite}
After the implementation of wrk files, it was discussed whether or not the NetCDF should be implemented and it was decided that the time cost were too big to meet the deadline. Instead it was concluded that the flexibility of the application was good enough to allow extending the application to support other file formats, including NetCDF, at a later date and the focus was shifted to the frontend.

\subsection{Grouping wrk}
The big amount of wrk files for each radar (1 every \textasciitilde 10 minutes for a total of 144 files per day) causes a bit of confusion in the file administration of the control panel.

It was suggested that the administration panel grouped the wrk files per day, or that the data parser combined one day of wrk files into one file before importing it into the database.

The idea of letting the data parser to handle the merge was dropped due to the complexity. A merge in the data parser would also increase the memory usage by the data parser, which might not be available on the web server running the application.

Lack of time prevented the implementation of file grouping by the administration panel because of the work involved in finding the files that should be grouped together.

\subsection{Data date range}
As time goes by, one would expect the application to contain massive amounts of data.
In the provided test data\footnote{Data02122.tar.gz provided by Pierre-Julien Trombe on CampusNet}, the application contains \textasciitilde 140 rows of data for \textsf{wrk} files and \textasciitilde 73,000 rows of data for the wind farm data.

It was discussed how we should limit the view of data, since it would require quite a lot of processing power to display that much data.

For the wind farm chart, we went from 1-month, weekly and daily view to 2-week, weekly and daily.
Preliminary tests showed that the loading time for 1-month view was too slow, because of the huge amount of data that had to be processed and formatted correctly before sent to the browser. The data would also take long to download, especially if not on a high speed internet connection.

Another problem was the radar images. Without any data range, they would all start at the first image taken by that radar, and play till the last. A range chosen by the user from a `to' and `from' date field was suggested. After testing the first implementation it was found that the `to' field was a bit confusing and would result in a bit of a rewrite of already existing code.

The `to' field was removed and the `from' field now decides the starting date for all radars and wind farm charts.
All radars will start their animation on the first image taken after the selected from date.
The chart will also start at the selected start date, but the navigation buttons allows one to go either back or forth in time independent of the selected from date.

\subsection{Choice of map}
After comparing the two maps (table \ref{tab:osm_vs_google}), it quickly became OpenStreetMap. It was partly because Google wants money if the map is used for commercial purposes and because the data is copyrighted and owned by multiple organisations. This wasn't the way we were thinking about open source.

OpenStreetMap wasn't that difficult to work with, due to the very well documentation from leaflet\footnote{See \cite{leaflet} for the documentation}.

There have been several design ideas. Many changes through the project and many considerations.

\subsubsection{Map}
At the beginning we had a sidebar which could be visible or hidden (figure \ref{fig:map_v1}). Later we found out that there is no need for a big menu, so we removed the sidebar and added a tiny top bar, with only the necessary options.\\
First mockup:
\begin{figure}[htbp]
   \centering
   \includegraphics[scale=.3]{figure/design_map_v1.eps}
   \caption{Map - version 1}
   \label{fig:map_v1}
\end{figure}

We\todo[fancyline,color=green]{Remove we} would have like to have had different layers on the map at the beginning, but this was unnecessary, so it was quickly removed.\\
Now we have created a cool design which is easy to get used to and all relevant informations can be accessed easily and without to much clicking (figure \ref{fig:map_final}).
There had also been added some gestures to control the radar easily.\\
The top bar has a date field to know which date the radar should get data from. This date will be transferred to the chart window.

\begin{figure}[htbp]
   \centering
   \includegraphics[width=1\linewidth]{figure/design_map_final.eps}
   \caption{Map - final}
   \label{fig:map_final}
\end{figure}

\subsubsection{Chart}
At the beginning we had the same sidebar as on the map, but with other options (figure \ref{fig:chart_v1}). This was also replaced by a top bar like on the map.\\
First mockup: 
\begin{figure}[htbp]
   \centering
   \includegraphics[width=1\linewidth]{figure/design_chart_v1.eps}
   \caption{Chart pop up - version 1}
   \label{fig:chart_v1}
\end{figure}

This has, through the whole project, been determined to be a pop up on the map.
The control buttons were before 'fast backward', 'backward', 'today', 'forward' and 'fast forward', but 'today' was replaced with 'play'. The 'play' button moves the chart every second, so the user can view the chart animated.\\
The new design also has three different views '2-week', 'weekly' and 'daily view' (figure \ref{fig:chart_final}). Control buttons adjust to the view the user has selected.

\begin{figure}[htbp]
   \centering
   \includegraphics[width=1\linewidth]{figure/design_chart_final.eps}
   \caption{Chart pop up - final}
   \label{fig:chart_final}
\end{figure}

% db.tex should start at section level
\input{tex/db}

% api.tex should start at section level
\input{tex/api}